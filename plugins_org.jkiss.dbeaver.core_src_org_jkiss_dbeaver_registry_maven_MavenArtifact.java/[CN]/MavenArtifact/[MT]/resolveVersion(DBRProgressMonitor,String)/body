{
  monitor.beginTask("Download Maven artifact '" + this + "'",3);
  try {
    monitor.subTask("Download metadata from " + repository.getUrl());
    loadMetadata();
    monitor.worked(1);
    String versionInfo=versionRef;
    List<String> allVersions=versions;
    if (versionInfo.equals(MavenArtifactReference.VERSION_PATTERN_RELEASE)) {
      versionInfo=releaseVersion;
    }
 else     if (versionInfo.equals(MavenArtifactReference.VERSION_PATTERN_LATEST)) {
      versionInfo=latestVersion;
    }
 else {
      if (versionInfo.startsWith("[") && versionInfo.endsWith("]")) {
        String regex=versionInfo.substring(1,versionInfo.length() - 1);
        try {
          Pattern versionPattern=Pattern.compile(regex);
          List<String> versions=new ArrayList<String>(allVersions);
          Collections.reverse(versions);
          for (          String version : versions) {
            if (versionPattern.matcher(version).matches()) {
              versionInfo=version;
              break;
            }
          }
        }
 catch (        Exception e) {
          throw new IOException("Bad version pattern: " + regex);
        }
      }
    }
    if (CommonUtils.isEmpty(versionInfo)) {
      if (allVersions.isEmpty()) {
        throw new IOException("Artifact '" + this + "' has empty version list");
      }
      versionInfo=allVersions.get(allVersions.size() - 1);
    }
    monitor.subTask("Download binaries for version " + versionInfo);
    MavenLocalVersion localVersion=getActiveLocalVersion();
    if (localVersion == null) {
      makeLocalVersion(versionInfo,true);
    }
    monitor.worked(1);
    monitor.subTask("Save repository cache");
    repository.flushCache();
    monitor.worked(1);
  }
  finally {
    monitor.done();
  }
}
